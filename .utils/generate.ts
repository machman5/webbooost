#!/usr/bin/env ts-node-script

import * as path from 'path'
import * as fs from 'fs'
import { log } from 'console'

const j = (...parts: string[]) =>
  path.join(...parts)

const rd = (path: fs.PathLike) =>
  fs.readdirSync(path)

const rdd = (path: fs.PathLike) =>
  fs.readdirSync(path, { withFileTypes: true })

const st = (path: fs.PathLike) =>
  fs.statSync(path)

const w = (content: string, path: string) =>
  fs.writeFileSync(path, content)

const toTSFile = (obj: object) => 
  `// this file is autogenerated. Do not modify by hands!
export default ${JSON.stringify(obj, null, 2)}`

const rootPath = path.resolve('../')
const injecteesPath = j(rootPath, 'injectees')
const hashPath = j(rootPath, 'src', 'configs', 'hash-gen.ts')
const regPath = j(rootPath, 'src', 'configs', 'reg-gen.ts')

const dirs = rd(injecteesPath)

interface Injectee {
  path: string
  name: string
  descriptor: Descriptor
  files: InjecteeFile[]
  versions: Version[]
}

interface InjecteeFile {
  name: string
  path: string
  relativePath?: string
  type: string
  version: string
}

interface Version {
  value: string
  path: string
}

interface Descriptor {
  urls: string[]
  filepath?: string
}

function parseInjectees(dir: string): Injectee[] {
  let result = []
  for (const mod of dirs) {
    // with every module dir
    const modPath = j(injecteesPath, mod)
    const modInternals = rd(modPath)

    if (modInternals.includes('descriptor.json')) {
      const injectee = parseInjectee(mod, modPath)
      injectee && result.push(injectee)
    }
  }

  return result;
}

function parseInjectee(name: string, filepath: string): Injectee {
  const descriptor = parseDescriptor(filepath)
  const versions: Version[] = parseVersions(name, filepath, descriptor)
  const files: InjecteeFile[] = parseFiles(name, versions);

  const injectee: Injectee = {
    path: filepath,
    name, 
    descriptor,
    versions,
    files
  }

  return injectee.descriptor ? injectee : null
}

function parseDescriptor(filepath: string): Descriptor {
  const descriptorPath = j(filepath, 'descriptor.json')
  try {
    return require(descriptorPath)
  } catch (e) {
    console.error(`Reading descriptor for ${descriptorPath} resulted in error:`, e)
    return null
  }
}

function parseVersions(name: string, filepath: string, descriptor: Descriptor): Version[] {
  let versions: Version[] = []
  const dirs = rd(filepath)

  for (const dir of dirs) {
    const dirPath = j(filepath, dir)
    if (isVersionDir(dirPath)) {
      versions.push({
        path: j(filepath, dir),
        value: dir
      })
    }
    
    // no version folders, just file and descriptor
    if (dirs.length === 2 && !isVersionDir(dirPath) && dir !== 'descriptor.json') {
      versions.push({
        value: '',
        path: j(filepath, dir)
      })
    }
  }
  
  return versions
}

function isVersionDir(dir: string): boolean {
  const stat = fs.statSync(dir)

  if (stat.isDirectory()) {
    const inside = rd(dir)
  
    if (inside.length === 1) {
      const firstFilePath = j(dir, inside[0]);
      return stat.isDirectory() && fs.statSync(firstFilePath).isFile()
    } else {
      return stat.isDirectory()
    }
  }
}

function parseFiles(name: string, versions: Version[]): InjecteeFile[] {
  let result: InjecteeFile[] = []
  for (const v of versions) {
    result = result.concat(walkTree(name, v, v.path, parseFile))
  }
  return result
}

function walkTree(name: string, version: Version, fpath: string, fn: (f: string, v: Version, path: string, name: string) => InjecteeFile): InjecteeFile[] {
  let result: InjecteeFile[] = []
  try {
    const list = rdd(fpath)

    for (const l of list) {
      if (l.isDirectory()) {
        result = result.concat(walkTree(name, version, j(version.path, l.name), fn))
      } else {
        result.push(fn(l.name, version, fpath, name)) 
      } 
    }
  } catch (e) {
    result.push(fn('', version, fpath, name)) 
  }
  
  return result
}

function parseFile(filename: string, version: Version, path: string, name: string): InjecteeFile {
  const fullpath = j(path, filename)
  return {
    name: filename,
    path: fullpath,
    version: version.value,
    type: parseFileType(fullpath, version.value, filename),
    relativePath: j(name, path.split(name)[1], filename)
  }
}

function parseFileType(path: string, version: string, name: string) {
  if (version === '') return ''
  return path.split(version)[1].split(name)[0].replace(/\//g,'')
}

function generateHashConfig(injectees: Injectee[]) {
  let mapping: { [k: string]: string } = {}
  
  injectees.reduce(
    (map, injectee) => { 
      injectee.files.forEach(file => {
        injectee.descriptor.urls.forEach(
          cdnUrl => {
            cdnUrl = cdnUrl
              .replace('$version$', file.version)
              .replace('$filetype$', file.type)
              .replace('$filename$', file.name)
            
            map[cdnUrl] = file.relativePath
          }
        )
      })
      return map
    },
    mapping
  )

  return mapping
}

function generateRegConfig(injectees: Injectee[]) {
  const mapping = {}

  return mapping
}


console.log(`Parsing injectees files from ${injecteesPath}\n`)
// get all injectee files with versions
const injectees = parseInjectees(process.cwd())
const hash = generateHashConfig(injectees)
const reg = generateRegConfig(injectees)

const result = 
  `ðŸ“¦ Total injectees: ${injectees.length}
ðŸ“¦ Total files: ${injectees.reduce((s, j) => s + j.files.length, 0)}

ðŸ”¡ Hash config generated. Total rules: ${Object.keys(hash).length}
ðŸ”Ž Reg config generated. Total rules:${Object.keys(reg).length}
`


console.log(result);

w(toTSFile(hash), hashPath)
console.log(`ðŸ“¥ Hash config written to ${hashPath}`)

w(toTSFile(reg), regPath)
console.log(`ðŸ“¥ Reg config written to ${regPath}`)

// console.log(JSON.stringify(injectees[11], null, 2))